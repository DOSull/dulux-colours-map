---
title: "Mapping the Dulux colours of New Zealand using R"
author: "David O'Sullivan"
date: September 2021

output:
  revealjs::revealjs_presentation:
    incremental: TRUE
    center: TRUE
    theme: sky
    transition: slide
    background-transition: none
    css: "slides/extra-styles.css"
    reveal_options:
      slideNumber: TRUE
      loop: TRUE
---

# Libraries {data-background="otago.png"}
We need a bunch of these...

## JSON processing {data-background="otago.png"}
First `jsonlite` for processing the colours data pulled from the website

```{r}
library(jsonlite)
```

## Data wrangling {data-background="otago.png"}
Next, a bunch of data munging packages from the 'tidyverse'

```{r message = FALSE}
library(tidyr)
library(plyr) ## rbind.fill for ragged data with missing entries
library(dplyr)  
library(magrittr)
library(tibble)
library(stringr)
```

## Spatial {data-background="otago.png"}
Next, the basic R spatial packages

```{r message = FALSE}
library(sf)
library(raster)
library(tmap)
library(tmaptools) ## for geocode_OSM
tmap_mode("plot") ## for static maps
```

## Interpolation {data-background="otago.png"}
Finally, a range of interpolation tools

```{r message = FALSE}
library(spatstat) ## for IDW
library(maptools)
library(akima)    ## for triangulation
library(fields)   ## for splines
```

# Getting the colours {data-background="bankes.png"}

See [the Dulux website](https://www.dulux.co.nz/colour/colours-of-new-zealand) for what this is all about

First I had a poke around on the website to figure out where the colour details were to be found

```{r}
colour_groups <- c("blues", "browns", "greens", "greys", "oranges",
                  "purples", "reds", "whites-neutrals", "yellows")
base_url <- "https://www.dulux.co.nz/content/duluxnz/home/colour/all-colours.categorycolour.json/all-colours/"
```

## Retrieve and save the colours {data-background="bankes.png"}
The loop on the next slide

+ steps through the group names
+ retrieves the relevant JSON file
+ writes it out locally
+ adds the colours information to a list
+ then we make the list into a single table using `bind_rows`

## {data-background="bankes.png"}

```{r eval = FALSE}
colours <- list()
for (i in 1:length(colour_groups)) {
  colour_group <- colour_groups[i]
  json_url <- str_c(base_url, colour_group)
  json_file_name <- str_c(colour_group, ".json")
  json <- fromJSON(json_url, flatten = TRUE)
  ## make a local copy (just for convenience)
  write_json(json, json_file_name)
  ## get the colours information and add to list
  the_colours <- rbind.fill(json$categoryColours$masterColour.colours)
  colours[[i]] <- the_colours
  Sys.sleep(0.5) ## pause to not annoy the the server  
}
df_colours <- bind_rows(colours)
write.csv(df_colours, "dulux-colours-raw.csv", row.names = FALSE)
```

## Check we're all good {data-background="bankes.png"}
```{r echo = FALSE}
df_colours <- read.csv("dulux-colours-raw.csv")
```

```{r}
head(df_colours)
```

## Tidying up the names {data-background="bankes.png"}
There are paint names with modifiers as suffixes for different shades of particular colours, and we need to handle this

The modifiers are
```{r}
paint_modifiers <- c("Half", "Quarter", "Double")
```

## A _tidyverse_ pipeline {data-background="bankes.png"}
Here’s one way to clean this up (there are others…)

```{r eval = FALSE}
df_colours_tidied <- df_colours %>%
  ## remove some columns we won't be needing
  select(-id, -baseId, -woodType, -coats) %>%
  ## separate the name components, filling from the left with NAs if <5
  separate(name, into = c("p1", "p2", "p3", "p4", "p5"), sep = " ",
           remove = FALSE, fill = "left") %>%
  ## replace any NAs with an empty string
  mutate(p1 = str_replace_na(p1, ""),
         p2 = str_replace_na(p2, ""),
         p3 = str_replace_na(p3, ""),
         p4 = str_replace_na(p4, "")) %>%
  ## if p5 is a paint modifiers, then recompose name
  ## from p1:p4 else from p1:p5
  ## similarly keep modifier where it exists
  mutate(placename = if_else(p5 %in% paint_modifiers,
                       str_trim(str_c(p1, p2, p3, p4, sep = " ")),
                       str_trim(str_c(p1, p2, p3, p4, p5, sep = " "))),
         modifier = if_else(p5 %in% paint_modifiers,
                       p5, "")) %>%
  ## remove some places that are tricky to deal with later
  filter(!placename %in% c("Chatham Islands",
                           "Passage Rock",
                           "Auckland Islands",
                           "Cossack Rock")) %>%
  ## throw away variables we no longer and reorder
  select(name, placename, modifier, red, green, blue)

write.csv(df_colours_tidied, "dulux-colours.csv", row.names = FALSE)
```

# Build the spatial dataset {data-background="taranaki.png"}
Add `x` and `y` columns to our data for the coordinates

```{r echo = FALSE}
df_colours_tidied <- read.csv("dulux-colours.csv")
```

```{r}
df_colours_tidied_xy <- df_colours_tidied %>%
  mutate(x = 0, y = 0)
```

## Geocode with `tmaptools::geocode_OSM` {data-background="taranaki.png"}
Code on the next slide

+ goes through all the unique placenames
+ appends as many `x` `y` coordinates as we have space for (due to the modifiers) from the geocoding results

## {data-background="taranaki.png"}

**Best not to re-run this (it takes a good 10 minutes and it's not good to repeatedly geocode and hit the OSM server)**

```{r eval = FALSE}
for (placename in unique(df_colours_tidied_xy$placename)) {
  address <- str_c(placename, "New Zealand", sep = ", ")
  geocode <- geocode_OSM(address, as.data.frame = TRUE, return.first.only = FALSE)
  num_geocodes <- nrow(geocode)
  matching_rows <- which(df_colours_tidied_xy$placename == placename)
  for (i in 1:length(matching_rows)) {
    if (!is.null(geocode)) {
      if (num_geocodes >= i) {
        df_colours_tidied_xy[matching_rows[i], ]$x <- geocode$lon[i]
        df_colours_tidied_xy[matching_rows[i], ]$y <- geocode$lat[i]
      }  
    }
  }
  Sys.sleep(0.5) ## so as not to over-tax the geocoder
}
## Remove any we missed
df_colours_tidied_xy <- df_colours_tidied_xy %>%
  filter(x != 0 & y != 0)

write.csv(df_colours_tidied_xy, "dulux-colours-xy.csv", row.names = FALSE)
```

# Making maps {data-background="westland.png"}

```{r echo = FALSE}
df_colours_tidied_xy <- read.csv("dulux-colours-xy.csv")
```

Make the dataframe into a `sf` point dataset

```{r eval = FALSE}
dulux_colours_sf <- st_as_sf(df_colours_tidied_xy,
                     coords = c("x", "y"), ## columns with the coordinates
                     crs = 4326) %>%       ## EPSG:4326 for lng-lat
  st_transform(2193) %>%                   ## convert to NZTM
  ## and make an RGB column
  mutate(rgb = rgb(red / 255, green / 255, blue/ 255))

## jitter any duplicate locations
duplicate_pts <- which(duplicated(dulux_colours_sf$geometry) |
                       duplicated(dulux_colours_sf$geometry, fromLast = TRUE))
jittered_pts <- dulux_colours_sf %>%
  slice(duplicate_pts) %>%
  st_jitter(50)
dulux_colours_sf[duplicate_pts, ]$geometry <- jittered_pts$geometry

st_write(dulux_colours_sf, "dulux-colours-pts.gpkg", delete_dsn = TRUE)
```

## {data-background="westland.png"}

Remember to update points dataframe with the jittered points

```{r eval = FALSE}
jittered_pts <- dulux_colours_sf %>%
  st_coordinates() %>%
  as_tibble()
df_colours_tidied_xy <- df_colours_tidied_xy %>%
  mutate(x = jittered_pts$X, y = jittered_pts$Y)
write.csv(df_colours_tidied_xy, "dulux-colours-xy-jit.csv", row.names = TRUE)
```

## And at last a map! {data-background="westland.png"}

```{r echo = FALSE, message = FALSE, results = FALSE}
nz <- st_read("nz.gpkg")
```

```{r echo = FALSE, message = FALSE, results = FALSE}
dulux_colours_sf <- st_read("dulux-colours-pts.gpkg")
df_colours_tidied_xy <- read.csv("dulux-colours-xy-jit.csv")
bbox <- bb(cx = 1.9e6, cy = 5.75e6, width = 3.2e5, height = 2.4e5)
```

```{r echo = FALSE}
tm_shape(nz, bbox = bbox) +
  tm_borders() +
  tm_shape(dulux_colours_sf) +
  tm_dots(col = "rgb", size = 0.5) +
  tm_text(text = "placename", size = 0.6, auto.placement = TRUE)
```

# We can do better (depending on taste!) {data-background="northland.png"}
Points aren't really much fun, instead:

+ [Voronoi polygons](#voronoi-polygons)
+ [Triangular facets](#triangulation)
+ [Inverse-distance weighted](#idw)
+ [Splines](#splines)

## Voronoi polygons {data-background="northland.png"}
We can make Voronois and clip to NZ

```{r eval = FALSE}
dulux_colours_vor <- dulux_colours_sf %>%
  st_union() %>%
  st_voronoi() %>%
  st_cast() %>%
  st_as_sf() %>%
  st_join(dulux_colours_sf, left = FALSE) %>%
  st_intersection(st_read("nz.gpkg"))

st_write(dulux_colours_vor, "dulux-colours-vor.gpkg", delete_dsn = TRUE)
```

## {data-background="northland.png"}

```{r echo = FALSE, message = FALSE, results = FALSE}
dulux_colours_vor <- st_read("dulux-colours-vor.gpkg")
```

```{r echo = FALSE}
tm_shape(dulux_colours_vor, bbox = bbox) +
  tm_polygons(col = "rgb", alpha = 0.75, border.col = "#ddeeff", lwd = 0.2)
```

## Triangulation {data-background="northland.png"}
Using the `akima::interp` package

```{r eval = FALSE}
components = c("red", "green", "blue")

layers = list()
for (component in components) {
  ## the dimensions, nx, ny give ~2500m resolution
  layers[[component]] <- raster(
    interp(df_colours_tidied_xy$x, df_colours_tidied_xy$y, 
           df_colours_tidied_xy[[component]],
           nx = 402, ny = 591, linear = TRUE))
}
rgb.t <- brick(layers)
crs(rgb.t) <- st_crs(nz)$wkt
rgb.t <- mask(rgb.t, nz)

writeRaster(rgb.t, "dulux-colours-tri.tif", overwrite = TRUE)
```

## {data-background="northland.png"}

```{r echo = FALSE, message = FALSE, warning = FALSE}
rgb.t <- raster("dulux-colours-tri.tif")
```

```{r echo = FALSE}
tm_shape(rgb.t, bbox = bbox) + 
  tm_rgb()
```

## IDW {data-background="northland.png"}
Here we use the `spatstat::idw` function

We need `spatstat::ppp` (point pattern) objects

```{r eval = FALSE}
## We need a window for the ppps
W <- nz %>%
  st_geometry() %>%
  st_buffer(1000) %>%
  st_union() %>%
  as("Spatial") %>%
  as.owin()
 
layers <- list()
for (component in components) {
  pp <- ppp(x = df_colours_tidied_xy$x, 
            y = df_colours_tidied_xy$y, 
            window = W, 
            marks = df_colours_tidied_xy[[component]])
  ## eps is the approximate resolution
  layers[[component]] <- raster(idw(pp, eps = 2500, power = 4))
}
rgb.idw <- brick(layers)
crs(rgb.idw) <- st_crs(nz)$wkt

writeRaster(rgb.idw, "dulux-colours-idw.tif", overwrite = TRUE)
```

## {data-background="northland.png"}

```{r echo = FALSE, message = FALSE, warning = FALSE}
rgb.idw <- raster("dulux-colours-idw.tif")
```

```{r echo = FALSE}
tm_shape(rgb.idw, bbox = bbox) + 
  tm_rgb()
```

## Splines {data-background="northland.png"}
For this we use the `fields::Tps` (thin plate spline) function 

We need an empty raster to interpolate into

```{r eval = FALSE}
r <- nz %>% 
  st_make_grid(cellsize = 2500, what = "centers") %>%
  st_coordinates() %>%
  as_tibble() %>%
  rename(x = X, y = Y) %>%
  mutate(z = 0) %>%
  rasterFromXYZ()
```

## {data-background="northland.png"}

Then we can interpolate as before

```{r eval = FALSE}
layers <- list()
for (component in components) {
  spline <- Tps(df_colours_tidied_xy[, c("x", "y")], 
                df_colours_tidied_xy[[component]], 
                scale.type = "unscaled", m = 3)
  layers[[component]] <- interpolate(r, spline)
}
rgb.s <- brick(layers)
crs(rgb.s) <- st_crs(nz)$wkt
rgb.s <- mask(rgb.s, nz)

writeRaster(rgb.s, "dulux-colours-spline.tif", overwrite = TRUE)
```

## {data-background="northland.png"}

```{r echo = FALSE, message = FALSE, warning = FALSE}
rgb.s <- raster("dulux-colours-spline.tif", overwrite = TRUE)
```

```{r echo = FALSE}
tm_shape(rgb.s, bbox = bbox) + 
  tm_rgb()
```

# Credits and more

+ Maptime!
+ See [github.com/DOSull/dulux-colours-map](https://github.com/DOSull/dulux-colours-map) for the code
+ See the same place for other odds and ends I do (including my classes at Vic!)
+ All the amazing people behind:
    + _R_ and _RStudio
    + `sf` and `tmap` (for basic geospatial)
    + the _tidyverse_ packages
    + _RMarkdown_
    
    
```{r echo = FALSE, eval = FALSE}
get_rescale <- function(r1, r2) {
  range1 <- r1[2] - r1[1]
  range2 <- r2[2] - r2[1]
  scale <- range2 / range1
  return (function(x) {
    return(r2[1] + scale * (x - r1[1]))
  })
}

# rgb.s$red <- get_rescale(c(minValue(rgb.s$red), maxValue(rgb.s)), 
#                          range(rgb$red))(rgb.s$red)
# rgb.s$green <- get_rescale(c(minValue(rgb.s$green), maxValue(rgb.s$green)), 
#                            range(rgb$green))(rgb.s$green)
# rgb.s$blue <- get_rescale(c(minValue(rgb.s$blue), maxValue(rgb.s$blue)), 
#                           range(rgb$blue))(rgb.s$blue)

```

```{r echo = FALSE, eval = FALSE}
m1 <- tm_shape(vor) + 
  tm_polygons(col = "rgb", border.col = "#ddeeff", lwd = 0.1) +
  tm_layout(title = "Voronoi")
m2 <- tm_shape(rgb.idw) +
  tm_rgb() +
  tm_layout(title = "IDW of rgb")
m3 <- tm_shape(rgb.s) +
  tm_rgb() + 
  tm_layout(title = "Spline of rgb")

tmap_arrange(m1, m2, m3, nrow = 1)
```

```{r echo = FALSE, eval = FALSE}
get_CMYK <- Vectorize(function(R, G, B) {
  Rn <- R / 255
  Gn <- G / 255
  Bn <- B / 255
  K <- 1 - max(Rn, Gn, Bn)
  C <- ifelse(K == 1, 0, (1 - Rn - K) / (1 - K))
  M <- ifelse(K == 1, 0, (1 - Gn - K) / (1 - K))
  Y <- ifelse(K == 1, 0, (1 - Bn - K) / (1 - K))
  return(list(C = C, M = M, Y = Y, K = K));
})

get_R <- Vectorize(function(C, M, Y, K) {
  return(255 * (1 - C) * (1 - K))
})
get_G <- Vectorize(function(C, M, Y, K) {
  return(255 * (1 - M) * (1 - K))
})
get_B <- Vectorize(function(C, M, Y, K) {
  return(255 * (1 - Y) * (1 - K))
})
```

